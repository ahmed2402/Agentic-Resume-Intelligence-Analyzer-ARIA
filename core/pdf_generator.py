import os
import sys
import json
from dotenv import load_dotenv
from langchain_groq import ChatGroq
from fpdf import FPDF # For PDF generation

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from core.utils import process_documents
from core.embedding import calculate_resume_jd_similarity
from core.llm_interface import generate_insights # Though not strictly used for CV generation, kept for context or potential future use

load_dotenv()
groq_api_key = os.environ.get("GROQ_API_KEY")

if not groq_api_key:
    raise ValueError("GROQ_API_KEY not found in environment variables. Please set it in your .env file.")

groq_llm = ChatGroq(groq_api_key=groq_api_key, model_name="llama-3.1-8b-instant")

def generate_tailored_cv_content_from_llm(original_resume_text: str, jd_text: str) -> str:
    """
    Generates tailored CV content based on the original resume and a job description,
    using an LLM. The content will be structured for a new CV document.
    """
    prompt = f"""
You are an AI assistant specialized in tailoring resumes for specific job descriptions.
Your task is to create a new, tailored resume (CV) for a candidate based on their original CV and a target job description.

Here is the candidate's **original resume content**:
<ORIGINAL_RESUME>
{original_resume_text}
</ORIGINAL_RESUME>

Here is the **job description**:
<JOB_DESCRIPTION>
{jd_text}
</JOB_DESCRIPTION>

Based on the original resume and the job description, generate content for a **new, tailored CV**.
Focus on highlighting relevant skills, experiences, and achievements from the original resume that align best with the job description.

**Structure the tailored CV content as follows, using clear headings:**

# [Candidate Name] - Tailored for [Job Title from JD]

## Contact Information
- Phone: [Candidate Phone]
- Email: [Candidate Email]
- LinkedIn: [Candidate LinkedIn Profile]
- Portfolio/GitHub: [Candidate Portfolio/GitHub (if applicable)]

## Summary/Objective
- A concise, compelling summary tailored to the job description, highlighting key qualifications.

## Work Experience
- List 2-3 most relevant work experiences. For each:
    - **[Job Title]** at **[Company Name]** ([Start Date] â€“ [End Date])
    - Tailor bullet points to emphasize achievements and responsibilities directly relevant to the JD. Use quantifiable results.

## Education
- **[Degree]** in **[Major]** from **[University Name]** ([Graduation Year])
- Relevant coursework or academic projects.

## Skills
- Categorize skills (e.g., Technical Skills, Soft Skills, Tools & Technologies).
- List skills highly relevant to the JD first.

Ensure the language is professional and directly targets the job description. The output should be plain text, ready to be directly put into a PDF document.
"""

    try:
        response = groq_llm.invoke(prompt)
        return response.content
    except Exception as e:
        print(f"Error generating tailored CV content with LLM: {e}")
        return f"Error generating CV content: {e}"

def create_pdf_document(content: str, output_path: str, title: str = "Tailored Resume"):
    """
    Creates a PDF document from the given content using FPDF, formatted for a CV.
    """
    pdf = FPDF()
    pdf.add_page()

    # Add Arial font
    pdf.add_font("TimesNewRoman", "", r"../data/fonts/times.ttf")

    pdf.set_font("TimesNewRoman", "B", 20)
    # The title will be the candidate's name and tailored job title, as generated by the LLM
    # We will parse the first line of the content as the main title
    lines = content.split('\n')
    main_title = ""
    if lines and lines[0].strip().startswith("# "):
        main_title = lines.pop(0).replace("# ", "").strip()
    else:
        main_title = title # Fallback to default if LLM doesn't format correctly

    pdf.cell(0, 15, main_title, align='C', new_x="LMARGIN", new_y="NEXT")
    pdf.ln(5)

    pdf.set_font("Arial", "", 10)
    # Calculate effective page width for text
    page_width = pdf.w - 2 * pdf.l_margin

    for line in lines:
        line = line.strip()
        if not line: # Skip empty lines
            pdf.ln(3)
            continue

        if line.startswith("## "):
            pdf.set_font("Arial", "B", 12)
            pdf.ln(5) # Add extra space before main sections
            pdf.cell(page_width, 10, line.replace("## ", ""), align='L', new_x="LMARGIN", new_y="NEXT")
            pdf.ln(2)
        elif line.startswith("- "):
            pdf.set_font("Arial", "", 10)
            bullet_indent = 10 # Indent for bullet points
            # Calculate remaining width after indentation
            text_width = page_width - bullet_indent
            pdf.set_x(pdf.l_margin + bullet_indent) 
            pdf.multi_cell(text_width, 5, line, align='L')
        else:
            pdf.set_font("Arial", "", 10)
            pdf.multi_cell(page_width, 5, line, align='L')
    
    pdf.output(output_path)
    print(f"Tailored CV generated successfully at {output_path}")

def generate_tailored_resume_pdf(resume_path: str, jd_path: str, output_dir: str = "../data/output"):
    """
    Orchestrates the full process of generating a resume analysis PDF report.
    Includes ingestion, embedding, advisory, and PDF generation.
    """
    print("\n--- Starting Full PDF Report Generation Workflow ---")

    # Removed agent instantiation - directly using core functions

    try:
        # 1. Ingestion Phase
        print("\n--- Ingestion Phase ---")
        # using process_documents from core.utils
        processed_data = process_documents(resume_path, jd_path)
        original_resume_text = " ".join(processed_data["cleaned_resume"])
        jd_text = " ".join(processed_data["cleaned_job_description"])

        # 2. Embedding Phase (optional for CV generation, but good for context)
        print("\n--- Embedding Phase (for context) ---")
        # using calculate_resume_jd_similarity from core.embedding
        similarity_score = calculate_resume_jd_similarity(original_resume_text, jd_text)
        print(f"Initial Resume-JD Similarity Score: {similarity_score:.4f}")

        # 3. CV Content Generation Phase
        print("\n--- Tailored CV Content Generation Phase ---")
        # using generate_tailored_cv_content_from_llm from core/pdf_generator itself
        tailored_cv_content = generate_tailored_cv_content_from_llm(original_resume_text, jd_text)

        # 4. PDF Document Creation Phase
        print("\n--- Tailored CV Document Creation Phase ---")
        os.makedirs(output_dir, exist_ok=True)
        output_filename = os.path.join(output_dir, f"Tailored_CV_{os.path.basename(resume_path).split('.')[0]}.pdf")
        create_pdf_document(tailored_cv_content, output_filename, title=f"Tailored CV for {os.path.basename(resume_path).split('.')[0]}")

        print("\n--- Tailored CV Generation Workflow Completed ---")
        return output_filename

    except FileNotFoundError as e:
        print(f"Workflow Error: File not found - {e}")
        return None
    except NotImplementedError as e:
        print(f"Workflow Error: Feature not implemented - {e}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during the workflow: {e}")
        return None

if __name__ == "__main__":
    # Example Usage:
    RESUME_PATH = "../data/raw/resumes/Ahmed Raza - AI Engineer.pdf"
    JD_PATH = "../data/raw/job_descriptions/ai_engineer.txt"

    print("Starting PDF Report Generation Example...")
    output_pdf_path = generate_tailored_resume_pdf(RESUME_PATH, JD_PATH)

    if output_pdf_path:
        print(f"Full workflow completed. Report saved to: {os.path.abspath(output_pdf_path)}")
    else:
        print("Full workflow failed.")
