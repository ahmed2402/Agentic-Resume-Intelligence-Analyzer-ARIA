import os
import sys 
import json
import datetime 
from dotenv import load_dotenv
from langchain_groq import ChatGroq
from fpdf import FPDF # For PDF generation

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from core.utils import process_documents
load_dotenv()
groq_api_key = os.environ.get("GROQ_API_KEY")

if not groq_api_key:
    raise ValueError("GROQ_API_KEY not found in environment variables. Please set it in your .env file.")

groq_llm = ChatGroq(groq_api_key=groq_api_key, model_name="llama-3.1-8b-instant")

def generate_tailored_cv_content_from_llm(original_resume_text: str, original_jd_text: str) -> str:
    """
    Generates tailored CV content based on the original resume and a job description,
    using an LLM. The content will be structured for a new CV document.
    """
    prompt = f"""
You are an AI assistant specialized in tailoring resumes for specific job descriptions.
Your task is to create a new, tailored resume (CV) for a candidate based on their original CV and a target job description.

Here is the candidate's **original resume content**:
<ORIGINAL_RESUME>
{original_resume_text}
</ORIGINAL_RESUME>

Here is the **job description**:
<JOB_DESCRIPTION>
{original_jd_text}
</JOB_DESCRIPTION>

Based on the original resume and the job description, generate content for a **new, tailored CV**.
Focus on highlighting relevant skills, experiences, and achievements from the original resume that align best with the job description.

**Structure the tailored CV content as follows, using clear headings:**

# [Candidate Name] - Tailored for [Job Title from JD]

## Contact Information
- Phone: [Candidate Phone]
- Email: [Candidate Email]
- LinkedIn: [Candidate LinkedIn Profile]
- Portfolio/GitHub: [Candidate Portfolio/GitHub (if applicable)]

## Summary/Objective
- A concise, compelling summary tailored to the job description, highlighting key qualifications.

## Work Experience
- List 2-3 most relevant work experiences. For each:
    - **[Job Title]** at **[Company Name]** ([Start Date] â€“ [End Date])
    - Tailor bullet points to emphasize achievements and responsibilities directly relevant to the JD. Use quantifiable results.

## Education
- **[Degree]** in **[Major]** from **[University Name]** ([Graduation Year])
- Relevant coursework or academic projects.

## Skills
- Categorize skills (e.g., Technical Skills, Soft Skills, Tools & Technologies).
- List skills highly relevant to the JD first.

Ensure the language is professional and directly targets the job description. The output should be plain text, ready to be directly put into a PDF document.
"""

    try:
        response = groq_llm.invoke(prompt)
        return response.content
    except Exception as e:
        print(f"Error generating tailored CV content with LLM: {e}")
        return f"Error generating CV content: {e}"

def create_pdf_document(content: str, output_path: str, title: str = "Tailored Resume"):
    """
    Creates a PDF document from the given content using FPDF, formatted for a CV.
    """
    pdf = FPDF()
    pdf.add_page()

    # Add Times New Roman font
    pdf.add_font("TimesNewRoman", "", r"../data/fonts/times.ttf")
    pdf.add_font("TimesNewRoman", "B", r"../data/fonts/timesbd.ttf") # Assuming a bold variant exists

    pdf.set_font("TimesNewRoman", "B", 20)
    # The title will be the candidate's name and tailored job title, as generated by the LLM
    # We will parse the first line of the content as the main title
    lines = content.split('\n')
    main_title = ""
    if lines and lines[0].strip().startswith("# "):
        main_title = lines.pop(0).replace("# ", "").strip()
    else:
        main_title = title # Fallback to default if LLM doesn't format correctly

    pdf.cell(0, 15, main_title, align='C', new_x="LMARGIN", new_y="NEXT")
    pdf.ln(5)

    pdf.set_font("TimesNewRoman", "", 10)
    # Calculate effective page width for text
    page_width = pdf.w - 2 * pdf.l_margin

    for line in lines:
        line = line.strip()
        if not line: # Skip empty lines
            pdf.ln(3)
            continue

        if line.startswith("## "):
            pdf.set_font("TimesNewRoman", "B", 12)
            pdf.ln(5) # Add extra space before main sections
            pdf.cell(page_width, 10, line.replace("## ", ""), align='L', new_x="LMARGIN", new_y="NEXT")
            pdf.ln(2)
        elif line.startswith("- "):
            pdf.set_font("TimesNewRoman", "", 10)
            bullet_indent = 10 # Indent for bullet points
            # Calculate remaining width after indentation
            text_width = page_width - bullet_indent
            pdf.set_x(pdf.l_margin + bullet_indent) 
            pdf.multi_cell(text_width, 5, line, align='L')
        else:
            pdf.set_font("TimesNewRoman", "", 10)
            pdf.multi_cell(page_width, 5, line, align='L')
    
    pdf.output(output_path)
    print(f"Tailored CV generated successfully at {output_path}")

def generate_tailored_resume_pdf(original_resume_text: str, original_jd_text: str, output_filename_prefix: str = "Tailored_CV", output_dir: str = "../data/output") -> str | None:
    """
    Generates a tailored CV in PDF format based on the original resume text and job description text.
    This function assumes the input texts are already cleaned and prepared.

    Args:
        original_resume_text (str): The cleaned text content of the user's original resume.
        jd_text (str): The cleaned text content of the job description.
        output_filename_prefix (str): Prefix for the output PDF filename. Defaults to "Tailored_CV".
        output_dir (str): The directory where the generated PDF will be saved. Defaults to "../data/output".

    Returns:
        str | None: The path to the generated PDF file if successful, otherwise None.
    """
    print("\n--- Starting Tailored CV Generation Workflow ---")

    try:
        # 1. CV Content Generation Phase
        print("\n--- Tailored CV Content Generation Phase ---")
        tailored_cv_content = generate_tailored_cv_content_from_llm(original_resume_text, original_jd_text)

        # 2. PDF Document Creation Phase
        print("\n--- Tailored CV Document Creation Phase ---")
        os.makedirs(output_dir, exist_ok=True)
        # A more robust way to get a name if original_resume_text doesn't directly map to a filename
        # For simplicity, we can use a generic name or ask for one in the agent's workflow
        # For now, let's use a timestamp or a generic identifier.
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        output_filename = os.path.join(output_dir, f"{output_filename_prefix}_{timestamp}.pdf")
        
        create_pdf_document(tailored_cv_content, output_filename)

        print("\n--- Tailored CV Generation Workflow Completed ---")
        return output_filename

    except Exception as e:
        print(f"An unexpected error occurred during the CV generation workflow: {e}")
        return None

if __name__ == "__main__":
    # Example Usage:
    RESUME_PATH = "../data/raw/resumes/Ahmed Raza - AI Engineer.pdf"
    JD_PATH = "../data/raw/job_descriptions/ai_engineer.txt"

    # Import for example usage only, simulating agent output

    print("Starting Tailored CV Generation Example...")
    try:
        print("Loading and cleaning documents for example (simulating Ingestion Agent output)...")
        processed_data = process_documents(RESUME_PATH, JD_PATH)
        original_resume_text = processed_data["raw_resume_text"]
        original_jd_text = processed_data["raw_jd_text"]

        output_pdf_path = generate_tailored_resume_pdf(original_resume_text, original_jd_text)

        if output_pdf_path:
            print(f"Full workflow completed. Tailored CV saved to: {os.path.abspath(output_pdf_path)}")
        else:
            print("Full workflow failed.")
    except Exception as e:
        print(f"An error occurred in the example usage: {e}")
